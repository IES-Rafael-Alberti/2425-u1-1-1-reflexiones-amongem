[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/Z6NE2ogx)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=16536984&assignment_repo_type=AssignmentRepo)
# Práctica 1: Introducción al desarrollo. Reflexiones.

Apoyate en los siguientes recursos para realizar la práctica:

[Descripción de la práctica](https://revilofe.github.io/section3/u01/practica/EDES-U1.-Practica010/)


---

# Título de la Actividad

## Identificación de la Actividad
- **ID de la Actividad:** Práctica 1.10: Preguntas sobre actividades.
- **Módulo:** EDES
- **Unidad de Trabajo:** U1: Introducción al Desarrollo de Software
- **Fecha de Creación:** 15-10-2024
- **Fecha de Entrega:** 17-10-2024
- **Alumno(s):** 
  - **Nombre y Apellidos:** Antonio José Monge Monge
  - **Correo electrónico:** amonmon0206@g.educaand.es
  - **Iniciales del Alumno/Grupo:** AMM 

## Descripción de la Actividad
Preguntas sobre la unidad 1 para ver y desarrollar el temario que hemos visto.

## Desarrollo de la Actividad
### Descripción del Desarrollo
[Explicación de cómo se ha abordado el desarrollo de la actividad, incluyendo las decisiones de diseño, estructura del código y enfoque de resolución de problemas. Se recomienda adjuntar diagramas o capturas de pantalla si es necesario.]


### Notas Adicionales:
1. **Nombres de Archivos y Repositorios:**
   - Asegúrate de que el nombre del archivo o repositorio siga la estructura definida: `XXX-idActividad-Iniciales`.
2. **Permisos:**
   - Verifica que el profesor tenga los permisos necesarios para acceder al repositorio o documento.
3. **Formato:**
   - Si se entrega en formato PDF o Google Docs, asegúrate de cumplir con el mínimo y máximo de folios establecidos.
4. **Compilación y Ejecución:**
   - Detalla claramente cómo compilar y ejecutar el código, incluyendo las instrucciones en el archivo `README.md`.


**1. Relación software y hardware**

***1.1 Primera parte***

1.1.1: El procesador recoge las instrucciones de un programa y realiza los cálculos necesarios para su funcionamiento.

1.1.2: Se encarga de almacenarla para posteriormente pasarle esa misma información al procesador. Depende de el estado de cada una de esas partes, se hará una acción u otra.

1.1.3: Mediante el sistema E/S del procesador. 

***1.2 Segunda parte***

1.2.1: Los perifericos envían una señal a la CPU, donde está lo almacena en la memoria RAM.

1.2.2: Estan cargados en la memoria, se procesan y almacenan temporalmente mientras se ejecuta el programa.

1.2.3: Servir las ordenes de como tiene que comportarse la bombilla.

1.2.4: Esto simula lo que es el funcionamiento de un ordenador por así decirlo, vemos como recibe distintas ordendes y van ejecutandose. 

**2. Del código fuente al ejecutable**

2.1.: El código fuente es lo que se escribe en el lenguaje de programación y el código objeto lo que sale de este una vez está compilado.

2.2.: Es el paso intermedia, necesita llegar a ser código ejecutable, que es lo que un ordenador ejecuta directamente.

2.3.: Es el encargado de unir todo en el archivo ejecutable. 

2.4.: Pues que no se podría obtener una aplicación funcional. 


**3. Generación de código intermedio.**

3.1.: Que es independiente de la máquina, pensando para ejecutarse en máquinas virtuales. 

3.2.: Te permiten utilizar múltiples sistemas operativos en el mismo hardware, con recursos optimizados. 

3.3.: Por la portabilidad, seguridad y la optimización que estas ofrecen.

3.4.: C y Kotlin, por ejemplo. 


**4. Lenguajes de Programación.**

***4.1 Primera parte***

4.1.1.: La compilación es un paso previo que produce un ejecutable. Y la ejecución directa lo ejecuta en el momento.

4.1.2.: En la compilación tiene que pasar dicho proceso para detectar el error, mientras que en la ejecución se detectan al momento de ejecutarse.

***4.2 Segunda parte***

4.2.1.: El lenguaje de alto nivel tiene más facilidad de uso para los humanos y el de bajo nivel es más complejo pero se tiene mayor control y eficiencia.

4.2.2.: 

 -Alto nivel: facilidad de uso, portabilidad. A costa de menor 
 control y rendimiento.
 -Bajo nivel: Más complejo y menos portatil, a cambio de un control y rendimiento mayor.

 ***4.3 Tercera parte***

 4.3.1.: Siguiendo el paradigma de programación orientada a objetos.

 4.3.2.: Al ser funciones puras, el código acaba resultando predecible y modular.

 ***4.4 Reflexión final***

 4.4.1.: De momento solo he usado Python, y casi (con perdón de la expresión) me cago encima. Veremos los demás lenguajes. 

 4.4.2.: El compilado se usa cuando se busca optimización, mejor rendimiento y seguridad.

 4.4.3.: Un lenguaje de alto nivel viene bien cuando se busca mayor facilidad de desarrollo, mantenimiento y portabilidad entre otras cosas.

 4.4.4.: El paradigma orientado a objetos es mas organizado y modular, mientras que el imperativo es más directo y el funcional es mas persistente.


 **5. Herramientas de Desarrollo**

 ***5.1 Primera parte***

5.1.1.: 

-_Sistemas de Gestión de versiones_: Permiten rastrear cambios en el código y trabajar con distintas ramas de desarrollo, sin sobreescribir datos ajenos.

-_Los frameworks_: Proporcionan estructura para desarrollar aplicaciones y creación de proyectos con la ayuda de librerías.

-_Herramientas de pruebas_: Se aseguran de que el sofware funcione como debe.

-_Compiladores_: Se encarga de traducir el código fuente a código máquina.

-_Editor de texto_: Es una herramienta que se usa para escribir el código fuente del programa.

5.1.2.:

-_Sistemas de Gestión de versiones_: Facilita el trabajo en equipo, ya que permite gestionar diferentes versiones del código y la monitorización de los cambios en este. 

-_Frameworks_: Acelerar el desarrollo de aplicaciones web en Python. 

-_Herramientas de pruebas_: Sirven para verificar que el software cumple con su rendimiento y calidad prometidos.

-_Compiladores_: Usados para cuando se quieren programas de alto rendimiento.

-_Editor de texto_: Uso principal en la edición rápida de código fuente, scripts o archivos de configuración.

5.1.3.: Dentro de los Sistemas de Gestión de Versiones, Están _Git_ y _Mercurial_. Git se diferencia de Mercurial en su modelo de datos, interfaz, rendimiento, facilidad de uso y sobretodo en popularidad.

5.1.4.: Git es un poco embrollo al principio, sobretodo si no has tocado mucho el tema de terminales, pero una vez empiezas a usarlo y sobretodo cagada tras cagada, ya lo vas entendiendo mejor.

5.1.5.: VisualCode es ideal para los primeros usuarios, ya que cuenta con una interfaz muy buena y bonita. Además de estar muy bien optimizado, más tener casi todos los lenguajes más populares. Le suman puntos la pestaña de _Extensiones_ que te permiten hacer todo eso, aún más eficaz.

5.1.6.: Pytest, es una herramienta de pruebas y calidad de código, me resulto un poco lioso al principio pero era por no poner las indicaciones correctamente. 

***5.2 Segunda parte***

5.2.1.: Git se considera muy útil al dejarte manejar distintos programas y poner la versión que quieras de ellos sin alterar su resultado. Es como una máquina del tiempo. 

5.2.2.: Git es muy fácil de usar (cuando le coges el truco), _Mercurial_ es menos complejo y dispone de algo menos de libertad en cuanto a comandos se refiere. Pero por ello, podría ser mejor para el usuario principiante. Recomendaría darse de cabezazos con Git, ya que vería tontería perder el tiempo con Mercurial. 

5.2.3.: Como más intuitiva VisualCode, ya que solo tendrías que seleccionar tu idioma y a _pa' lante_.

5.2.4.: Se usa un compilador cuando se quiere maximizar, optimizar y más seguridad.

5.2.5.: Para el desarrollo de aplicaciones web en _Python_.

***5.3 Reflexión final***

5.3.1.: El impacto es que facilitan por muchísimo el trabajo al programador, haciendo todo el proceso más ameno e incluso más fácil.

5.3.2.: Que haga la experiencia de programar menos tortuosa de lo que ya es (broma). Optimizar mis programas y hacerme saber qué hago mal.

5.3.3.: Las que he probado me han resultado interesantes, y realmente he visto lo importantes que son. Cada una de ellas totalmente necesarias.



